// ============================================
// PARTICLE SYSTEM
// ============================================

function createParticleExplosion(x, y, z, color, count = 30) {
    for (let i = 0; i < count; i++) {
        const geometry = new THREE.SphereGeometry(0.15, 8, 8);
        const material = new THREE.MeshBasicMaterial({ 
            color: color,
            transparent: true
        });
        const particle = new THREE.Mesh(geometry, material);
        
        particle.position.set(x, y, z);
        
        // Random velocity
        particle.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.4,
            Math.random() * 0.4 + 0.2,
            (Math.random() - 0.5) * 0.4
        );
        
        particle.userData.life = 1.0;
        particle.userData.decay = 0.02 + Math.random() * 0.02;
        
        scene.add(particle);
        particles.push(particle);
    }
}

function createTrailParticle(x, y, z) {
    const geometry = new THREE.SphereGeometry(0.3, 8, 8);
    const material = new THREE.MeshBasicMaterial({
        color: 0x00ff88,
        transparent: true,
        opacity: 0.6
    });
    const particle = new THREE.Mesh(geometry, material);
    
    particle.position.set(x, y, z);
    particle.userData.life = 1.0;
    particle.userData.isTrail = true;
    
    scene.add(particle);
    particles.push(particle);
}

// ============================================
// INPUT HANDLING
// ============================================

function setupInput() {
    const canvas = renderer.domElement;
    
    // Touch Events
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
    
    // Mouse Events
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    
    // Keyboard Events
    document.addEventListener('keydown', handleKeyDown);
}

function handleTouchStart(e) {
    if (!gameState.isPlaying || gameState.isPaused) return;
    e.preventDefault();
    
    isDragging = true;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
}

function handleTouchMove(e) {
    if (!gameState.isPlaying || gameState.isPaused || !isDragging) return;
    e.preventDefault();
    
    const touchX = e.touches[0].clientX;
    const deltaX = touchX - touchStartX;
    
    if (Math.abs(deltaX) > swipeThreshold) {
        if (deltaX > 0 && targetLane < 1) {
            changeLane(1);
        } else if (deltaX < 0 && targetLane > -1) {
            changeLane(-1);
        }
        touchStartX = touchX;
    }
}

function handleTouchEnd(e) {
    isDragging = false;
}

function handleMouseDown(e) {
    if (!gameState.isPlaying || gameState.isPaused) return;
    isDragging = true;
    touchStartX = e.clientX;
}

function handleMouseMove(e) {
    if (!gameState.isPlaying || gameState.isPaused || !isDragging) return;
    
    const deltaX = e.clientX - touchStartX;
    
    if (Math.abs(deltaX) > swipeThreshold) {
        if (deltaX > 0 && targetLane < 1) {
            changeLane(1);
        } else if (deltaX < 0 && targetLane > -1) {
            changeLane(-1);
        }
        touchStartX = e.clientX;
    }
}

function handleMouseUp(e) {
    isDragging = false;
}

function handleKeyDown(e) {
    if (!gameState.isPlaying || gameState.isPaused) return;
    
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
        if (targetLane > -1) changeLane(-1);
    } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
        if (targetLane < 1) changeLane(1);
    }
}

function changeLane(direction) {
    targetLane += direction;
    targetLane = Math.max(-1, Math.min(1, targetLane));
    createTrailParticle(ball.position.x, ball.position.y, ball.position.z);
}

// ============================================
// COLLISION DETECTION
// ============================================

function checkCollision() {
    for (let obstacle of obstacles) {
        if (obstacle.position.z > ball.position.z - 2 && 
            obstacle.position.z < ball.position.z + 2) {
            
            const distance = Math.abs(ball.position.x - obstacle.position.x);
            
            if (distance < 1.5) {
                return true;
            }
        }
    }
    return false;
}

// ============================================
// GAME STATE MANAGEMENT
// ============================================

function startGame() {
    console.log('ðŸŽ® Starting game...');
    
    gameState.isPlaying = true;
    gameState.isPaused = false;
    gameState.score = 0;
    gameState.speed = 0.2;
    gameState.difficulty = 1;
    
    targetLane = 0;
    currentLane = 0;
    obstacleSpawnTimer = 0;
    lastObstacleNumber = 1;
    
    ball.position.set(lanePositions[1], 1.5, 0);
    
    // Clear obstacles and particles
    obstacles.forEach(obs => scene.remove(obs));
    obstacles = [];
    particles.forEach(p => scene.remove(p));
    particles = [];
    
    // Update UI
    updateScoreDisplay();
    document.getElementById('menu-screen').classList.remove('active');
    document.getElementById('gameover-screen').classList.remove('active');
    document.getElementById('pause-screen').classList.remove('active');
    document.getElementById('score-display').classList.add('active');
    document.getElementById('game-controls').classList.add('active');
    document.getElementById('instructions').classList.add('active');
}

function gameOver() {
    console.log('ðŸ’¥ Game Over! Score:', gameState.score);
    
    gameState.isPlaying = false;
    
    // Save high score
    if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        saveHighScore();
    }
    
    // Create explosion effect
    createParticleExplosion(
        ball.position.x, 
        ball.position.y, 
        ball.position.z, 
        0xff3366, 
        50
    );
    
    // Update UI
    document.getElementById('final-score-value').textContent = gameState.score;
    document.getElementById('best-score-value').textContent = gameState.highScore;
    
    setTimeout(() => {
        document.getElementById('gameover-screen').classList.add('active');
        document.getElementById('score-display').classList.remove('active');
        document.getElementById('game-controls').classList.remove('active');
        document.getElementById('instructions').classList.remove('active');
    }, 500);
}

function togglePause() {
    if (!gameState.isPlaying) return;
    
    gameState.isPaused = !gameState.isPaused;
    
    if (gameState.isPaused) {
        document.getElementById('pause-screen').classList.add('active');
        document.getElementById('pause-btn').querySelector('.btn-icon').textContent = 'â–¶';
    } else {
        document.getElementById('pause-screen').classList.remove('active');
        document.getElementById('pause-btn').querySelector('.btn-icon').textContent = 'â¸';
    }
}

function updateScoreDisplay() {
    document.querySelector('.score-number').textContent = gameState.score;
}

function addScore(points = 1) {
    gameState.score += points;
    updateScoreDisplay();
    
    // Increase difficulty
    gameState.difficulty = 1 + gameState.score * 0.008;
    gameState.speed = Math.min(0.4, 0.2 + gameState.score * 0.003);
    obstacleSpawnInterval = Math.max(50, 100 - gameState.score * 0.5);
}

// ============================================
// GAME UPDATE LOOP
// ============================================

function updateGame() {
    if (!gameState.isPlaying || gameState.isPaused) return;
    
    // Update road curve
    roadCurve += roadCurveSpeed * gameState.speed * 10;
    const curveOffset = Math.sin(roadCurve) * roadCurveAmount;
    
    // Move and curve road segments
    road.forEach((segment) => {
        segment.position.z += gameState.speed * 2;
        
        // Apply curve
        const distanceFromCamera = Math.abs(segment.position.z - ball.position.z);
        const curveFactor = Math.min(1, distanceFromCamera / 30);
        segment.position.x = curveOffset * curveFactor;
        
        // Loop road
        if (segment.position.z > 10) {
            segment.position.z -= 200;
        }
    });
    
    // Update ball position (smooth lane transition)
    const targetX = lanePositions[targetLane + 1];
    ball.position.x += (targetX - ball.position.x) * 0.15;
    
    // Rotate ball
    ball.rotation.x += 0.08;
    ball.rotation.z += 0.04;
    
    // Pulse glow effect
    if (ballGlow) {
        const pulse = Math.sin(Date.now() * 0.005) * 0.1 + 0.9;
        ballGlow.scale.set(pulse, pulse, pulse);
    }
    
    // Spawn obstacles
    obstacleSpawnTimer++;
    if (obstacleSpawnTimer > obstacleSpawnInterval) {
        const lane = Math.floor(Math.random() * 3);
        lastObstacleNumber = (lastObstacleNumber % 99) + 1;
        createObstacle(lane, lastObstacleNumber);
        obstacleSpawnTimer = 0;
    }
    
    // Update obstacles
    obstacles.forEach((obstacle, index) => {
        obstacle.position.z += gameState.speed * 2;
        
        // Apply curve
        const distanceFromCamera = Math.abs(obstacle.position.z - ball.position.z);
        const curveFactor = Math.min(1, distanceFromCamera / 30);
        const baseLaneX = lanePositions[obstacle.userData.lane];
        obstacle.position.x = baseLaneX + curveOffset * curveFactor;
        
        // Rotate
        obstacle.rotation.y += obstacle.userData.rotationSpeed;
        
        // Remove passed obstacles
        if (obstacle.position.z > 5) {
            scene.remove(obstacle);
            obstacles.splice(index, 1);
            addScore(1);
        }
    });
    
    // Update particles
    particles.forEach((particle, index) => {
        if (particle.userData.velocity) {
            particle.position.add(particle.userData.velocity);
            particle.userData.velocity.y -= 0.015; // Gravity
        }
        
        particle.userData.life -= particle.userData.decay || 0.03;
        particle.material.opacity = particle.userData.life;
        
        if (particle.userData.isTrail) {
            particle.scale.multiplyScalar(0.95);
        }
        
        if (particle.userData.life <= 0) {
            scene.remove(particle);
            particles.splice(index, 1);
        }
    });
    
    // Update stars (parallax effect)
    stars.forEach(star => {
        star.position.z += gameState.speed * 0.5;
        if (star.position.z > 10) {
            star.position.z -= 200;
        }
    });
    
    // Update camera (smooth follow with offset)
    const cameraTargetX = ball.position.x * 0.3;
    const cameraTargetZ = ball.position.z + cameraSettings.distance;
    
    camera.position.x += (cameraTargetX - camera.position.x) * cameraSettings.followSpeed;
    camera.position.z += (cameraTargetZ - camera.position.z) * cameraSettings.followSpeed;
    
    // Camera look at point ahead of ball
    const lookAtPoint = new THREE.Vector3(
        ball.position.x * 0.5,
        ball.position.y,
        ball.position.z - cameraSettings.lookAheadDistance
    );
    camera.lookAt(lookAtPoint);
    
    // Add subtle camera shake at high speed
    if (gameState.speed > 0.3) {
        camera.position.y = cameraSettings.height + Math.sin(Date.now() * 0.01) * 0.1;
    }
    
    // Check collision
    if (checkCollision()) {
        gameOver();
    }
}

// ============================================
// ANIMATION LOOP
// ============================================

function animate() {
    requestAnimationFrame(animate);
    
    updateGame();
    
    renderer.render(scene, camera);
}

// ============================================
// UI EVENT HANDLERS
// ============================================

function setupUIEvents() {
    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('retry-btn').addEventListener('click', startGame);
    document.getElementById('menu-btn').addEventListener('click', () => {
        document.getElementById('gameover-screen').classList.remove('active');
        document.getElementById('menu-screen').classList.add('active');
    });
    
    document.getElementById('pause-btn').addEventListener('click', togglePause);
    document.getElementById('resume-btn').addEventListener('click', togglePause);
    document.getElementById('quit-btn').addEventListener('click', () => {
        gameState.isPlaying = false;
        document.getElementById('pause-screen').classList.remove('active');
        document.getElementById('menu-screen').classList.add('active');
        document.getElementById('score-display').classList.remove('active');
        document.getElementById('game-controls').classList.remove('active');
    });
    
    document.getElementById('sound-btn').addEventListener('click', () => {
        gameState.soundEnabled = !gameState.soundEnabled;
        const icon = document.getElementById('sound-btn').querySelector('.btn-icon');
        icon.textContent = gameState.soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
    });
}

// ============================================
// WINDOW RESIZE
// ============================================

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ============================================
// SAVE/LOAD
// ============================================

function saveHighScore() {
    try {
        localStorage.setItem('rushHighScore', gameState.highScore.toString());
        console.log('ðŸ’¾ High score saved:', gameState.highScore);
    } catch (e) {
        console.warn('Could not save high score');
    }
}

function loadHighScore() {
    try {
        const saved = localStorage.getItem('rushHighScore');
        if (saved) {
            gameState.highScore = parseInt(saved);
            document.getElementById('high-score-value').textContent = gameState.highScore;
            console.log('ðŸ“‚ High score loaded:', gameState.highScore);
        }
    } catch (e) {
        console.warn('Could not load high score');
    }
}

// ============================================
// START GAME
// ============================================

window.addEventListener('load', init);
console.log('ðŸš€ Rush 3D - Ready to start!');
