// ============================================
// RUSH 3D - PROFESSIONAL GAME ENGINE
// ============================================

// Game State Management
const gameState = {
    isPlaying: false,
    isPaused: false,
    score: 0,
    highScore: 0,
    speed: 0.2,
    difficulty: 1,
    soundEnabled: true
};

// Three.js Core Objects
let scene, camera, renderer;
let ball, ballGlow;
let road = [];
let obstacles = [];
let particles = [];
let stars = [];

// Game Mechanics
let roadCurve = 0;
let roadCurveSpeed = 0.015;
let roadCurveAmount = 3;
let targetLane = 0; // -1, 0, 1 (left, center, right)
let currentLane = 0;
let obstacleSpawnTimer = 0;
let obstacleSpawnInterval = 100;
let lastObstacleNumber = 1;

// Camera Settings
const cameraSettings = {
    distance: 12,
    height: 6,
    followSpeed: 0.12,
    lookAheadDistance: 8
};

// Input Handling
let touchStartX = 0;
let touchStartY = 0;
let isDragging = false;
const swipeThreshold = 40;

// Lane Positions
const lanePositions = [-3.5, 0, 3.5];
const laneWidth = 3;

// ============================================
// INITIALIZATION
// ============================================

function init() {
    console.log('ðŸŽ® Initializing Rush 3D...');
    
    // Create Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a);
    scene.fog = new THREE.FogExp2(0x0a0a0a, 0.015);

    // Create Camera
    camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.position.set(0, cameraSettings.height, cameraSettings.distance);

    // Create Renderer
    renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: false,
        powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Setup Lighting
    setupLighting();

    // Create Game Objects
    createBall();
    createRoad();
    createStarfield();

    // Setup Input
    setupInput();

    // Load Save Data
    loadHighScore();

    // Setup UI Events
    setupUIEvents();

    // Window Resize Handler
    window.addEventListener('resize', onWindowResize);

    // Hide Loading Screen
    setTimeout(() => {
        document.getElementById('loading-screen').classList.add('hidden');
    }, 500);

    // Start Animation Loop
    animate();
    
    console.log('âœ… Game initialized successfully!');
}

// ============================================
// LIGHTING SETUP
// ============================================

function setupLighting() {
    // Ambient Light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    // Main Directional Light
    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(5, 15, 5);
    mainLight.castShadow = true;
    mainLight.shadow.camera.left = -20;
    mainLight.shadow.camera.right = 20;
    mainLight.shadow.camera.top = 20;
    mainLight.shadow.camera.bottom = -20;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    scene.add(mainLight);

    // Colored Point Lights for Atmosphere
    const pointLight1 = new THREE.PointLight(0x00ff88, 1.5, 40);
    pointLight1.position.set(-8, 4, -10);
    scene.add(pointLight1);

    const pointLight2 = new THREE.PointLight(0xff0088, 1.5, 40);
    pointLight2.position.set(8, 4, -10);
    scene.add(pointLight2);

    const pointLight3 = new THREE.PointLight(0x00ddff, 1.5, 40);
    pointLight3.position.set(0, 4, -25);
    scene.add(pointLight3);

    // Hemisphere Light for Better Color
    const hemiLight = new THREE.HemisphereLight(0x00ddff, 0x1a1a2e, 0.5);
    scene.add(hemiLight);
}

// ============================================
// CREATE BALL
// ============================================

function createBall() {
    // Main Ball Geometry
    const geometry = new THREE.SphereGeometry(1, 32, 32);
    
    // Ball Material with Glow
    const material = new THREE.MeshPhongMaterial({
        color: 0x00ff88,
        emissive: 0x00ff88,
        emissiveIntensity: 0.6,
        shininess: 100,
        specular: 0xffffff
    });
    
    ball = new THREE.Mesh(geometry, material);
    ball.position.set(lanePositions[1], 1.5, 0);
    ball.castShadow = true;
    ball.receiveShadow = true;
    scene.add(ball);

    // Outer Glow Effect
    const glowGeometry = new THREE.SphereGeometry(1.4, 32, 32);
    const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff88,
        transparent: true,
        opacity: 0.3,
        side: THREE.BackSide
    });
    ballGlow = new THREE.Mesh(glowGeometry, glowMaterial);
    ball.add(ballGlow);

    // Inner Core
    const coreGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    const coreMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.8
    });
    const core = new THREE.Mesh(coreGeometry, coreMaterial);
    ball.add(core);

    // Ball Trail Group
    ball.userData.trail = [];
}

// ============================================
// CREATE ROAD
// ============================================

function createRoad() {
    const roadLength = 200;
    const segmentLength = 4;
    const roadWidth = 12;
    
    for (let i = 0; i < roadLength / segmentLength; i++) {
        const z = -i * segmentLength;
        
        // Main Road Segment
        const segmentGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
        const segmentMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9,
            metalness: 0.1
        });
        
        const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
        segment.rotation.x = -Math.PI / 2;
        segment.position.set(0, 0, z);
        segment.receiveShadow = true;
        scene.add(segment);
        road.push(segment);

        // Lane Dividers (Animated Lines)
        if (i % 2 === 0) {
            createLaneDivider(-laneWidth / 2, z);
            createLaneDivider(laneWidth / 2, z);
        }

        // Side Barriers (Glowing Walls)
        createSideBarrier(-roadWidth / 2, z, 0xff0088);
        createSideBarrier(roadWidth / 2, z, 0x00ddff);
    }
}

function createLaneDivider(x, z) {
    const geometry = new THREE.BoxGeometry(0.15, 0.05, 2);
    const material = new THREE.MeshBasicMaterial({
        color: 0x00ff88,
        transparent: true,
        opacity: 0.4
    });
    
    const divider = new THREE.Mesh(geometry, material);
    divider.position.set(x, 0.05, z);
    scene.add(divider);
    road.push(divider);
}

function createSideBarrier(x, z, color) {
    const geometry = new THREE.BoxGeometry(0.3, 2, 4);
    const material = new THREE.MeshPhongMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.6
    });
    
    const barrier = new THREE.Mesh(geometry, material);
    barrier.position.set(x, 1, z);
    scene.add(barrier);
    road.push(barrier);
}

// ============================================
// CREATE STARFIELD
// ============================================

function createStarfield() {
    const starGeometry = new THREE.SphereGeometry(0.1, 8, 8);
    const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    
    for (let i = 0; i < 200; i++) {
        const star = new THREE.Mesh(starGeometry, starMaterial);
        star.position.set(
            (Math.random() - 0.5) * 100,
            Math.random() * 50 + 10,
            (Math.random() - 0.5) * 200 - 50
        );
        scene.add(star);
        stars.push(star);
    }
}

// ============================================
// CREATE OBSTACLE (NUMBERED TRIANGLE)
// ============================================

function createObstacle(lane, number) {
    const group = new THREE.Group();
    
    // Triangle Pyramid (3-sided cone)
    const geometry = new THREE.ConeGeometry(1, 2, 3);
    const material = new THREE.MeshPhongMaterial({
        color: 0xff3366,
        emissive: 0xff3366,
        emissiveIntensity: 0.5,
        shininess: 80,
        flatShading: true
    });
    
    const pyramid = new THREE.Mesh(geometry, material);
    pyramid.rotation.y = Math.PI / 6;
    pyramid.castShadow = true;
    pyramid.receiveShadow = true;
    group.add(pyramid);

    // Glow Effect
    const glowGeometry = new THREE.ConeGeometry(1.3, 2.3, 3);
    const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0xff3366,
        transparent: true,
        opacity: 0.3,
        side: THREE.BackSide
    });
    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    glow.rotation.y = Math.PI / 6;
    group.add(glow);

    // Number Sprite
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;
    
    // Draw number with shadow
    context.shadowColor = 'rgba(0, 0, 0, 0.8)';
    context.shadowBlur = 10;
    context.shadowOffsetX = 3;
    context.shadowOffsetY = 3;
    
    context.fillStyle = '#ffffff';
    context.font = 'bold 140px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(number.toString(), 128, 128);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ 
        map: texture,
        transparent: true
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(2, 2, 1);
    sprite.position.y = 1.8;
    group.add(sprite);

    // Position
    group.position.set(lanePositions[lane], 1, -60);
    group.userData.lane = lane;
    group.userData.number = number;
    group.userData.rotationSpeed = 0.03 + Math.random() * 0.02;

    scene.add(group);
    obstacles.push(group);
}

// Continue to Part 2...
